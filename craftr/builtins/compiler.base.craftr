# craftr_module(compiler.base)
#
# Copyright (C) 2015 Niklas Rosenstein
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

from contextlib import contextmanager
from craftr.runtime import Target
from craftr.utils import get_calling_module

P = load_module('platform')


def options_override(base, options, merge_func):
  ''' Merges the values from the dictionary *options* into *base*.
  *merge_func* must be a callable and will be called for each key
  that is already present in *base*. The function signature is
  `(key, base_value, new_value) -> value`. Returns *base*. '''

  if not callable(merge_func):
    raise TypeError('merge_func not callable')
  for key, new_value in options.items():
    try:
      base_value = base[key]
    except KeyError as exc:
      pass
    else:
      new_value = merge_func(key, base_value, new_value)
    base[key] = new_value
  return base


class BaseCompiler(object):
  ''' Base class for implementing a compiler interface. All compilers
  are based on instance-local and method-local options. These options
  can be read from the `Optionable.options` attribute.

  Some of these options are not useful when set on the insance-local
  options.

  Options:
    debug (bool): False by default.
    exceptions (bool): True by default.
    warning_level (any): Not set by default.
    std (str): Not set by default. The name of the C/C++ standard.
    arch (str): Not set by default. The target architecture.
    output_type (str): The output type, can be "object", "executable",
      "shared_library" or "static_library".
    includes (list of str): A list of include paths.
    defines (list of str): A list of defines.
    ldpaths (list of str): A list of linker search paths.
    link_with (list of str): A list of libraries to link against.
    libs (list of str): A list of libraries to link against (full paths).
    external_libs (list of str): A list of libraries to link against
      (full paths). The difference to *libs* is that these are not listed
      as input files to a target (handled by rule functions).
    additional_flags (list of any): A list of additional arguments that
      should simply be appended to the command-line argument list.
  '''

  name = None
  version = None
  arch = None

  def __init__(self, **options):
    super().__init__()
    self.options = options
    self.init_default_options()

  def init_default_options(self):
    self.options.setdefault('debug', False)
    self.options.setdefault('exceptions', True)

  def invalid_option(self, option_name, value=NotImplemented, options=None):
    if options is None and value is NotImplemented:
      value = self.options.get(option_name)
    elif value is NotImplemented:
      value = options.get(option_name)
    raise ValueError('invalid option {}={!r}'.format(option_name, value))

  def detect(self, silent=False):
    ''' Detect the compiler version and target architecture. If *silent*
    is True, return True on success and False on error. Otherwise, raise
    an error using the modules `error()` built-in. '''

    raise NotImplementedError

  def flags(self, **options):
    ''' Generate compiler command-line arguments based on the *options*
    dictionary and return a list of those arguments. Should not take
    the instances `options` dictionary into account. For options that
    have a value of None or that are not set, no arguments must be
    generated. '''

    raise NotImplementedError

  def command(self, kind, **options):
    ''' Generate a compiler command-line based on the *options*
    dictionary and return a list of the command-line arguments. Likely
    to use `flags()` internally. '''

    raise NotImplementedError

  def merge_option(self, key, base_value, new_value):
    ''' Basic option merge function. Treats all keys the same.

    - Converts all `tuple` objects to `list`s
    - Combines *base_value* and *new_value* if both are lists
    - Otherwise, returns just *new_value*. '''

    if isinstance(base_value, tuple):
      base_value = list(base_value)
    if isinstance(new_value, tuple):
      new_value = list(new_value)
    if (type(base_value), type(new_value)) == (list, list):
      return base_value + new_value
    return new_value

  def merge_options(self, **options):
    return options_override(self.options.copy(), options, self.merge_option)

  def get_file_type(self, fn):
    raise NotImplementedError

  def process_inputs(self, module, inputs, options):
    ''' Process a list of inputs that can consist of targets and lists
    of object file names and returns a tuple of `(objects, libs)`. The
    compiler may also pre-process options. '''

    libs = list(options.get('libs', []))
    objects = []
    for target in inputs:
      if isinstance(target, Target):
        if target.meta.get('type') == 'objects':
          objects.extend(target.outputs)
        elif target.meta.get('type') == 'static_library':
          if len(target.outputs) != 1:
            message = 'static_library target {!r} has != 1 outputs.'
            raise ValueError(message.format(target.identifier))
          libs.append(target.outputs[0])
        elif target.meta.get('type') == 'shared_library':
          if len(target.outputs) != 1:
            message = 'shared_library target {!r} has != outputs.'
            raise ValueError(message.format(target.identifier))
          libs.append(target.outputs[0])
        else:
          message = 'what to do with target {!r}?'
          raise ValueError(message.format(target.identifier))
      else:
        for item in autoexpand(target):
          kind = self.get_file_type(item)
          if kind == 'object':
            objects.append(item)
          elif kind in ('static_library', 'shared_library'):
            libs.append(item)
          else:
            message = "can't handle {!r} file ({!r})"
            raise ValueError(message.format(item, kind))

    options['libs'] = libs
    return objects

  def objects(self, sources, build_dir=None, objects=None, description=None,
      module=None, target_name=None, **options):
    ''' Declares a target to build object files from the *sources*. The
    target has the meta type `"objects"`. The calling modules `build_dir`
    variable is used if *name* is a relative path. If the build directory
    is not specified, the current working directory is used. '''

    if not sources:
      raise ValueError('no sources specified')

    module = get_calling_module(module)
    build_dir = module.get('build_dir', '.')

    if objects is None:
      project_dir = module.get('project_dir')
      objects_dir = join(build_dir, 'obj')
      objects = move(P.obj(rmvsuffix(sources)), project_dir, objects_dir)
    if len(objects) != len(sources):
      raise ValueError('len(objects) must match len(sources)')
    if not description:
      description = 'Building Object %%out'

    options['output_type'] = 'object'
    options = self.merge_options(**options)

    command = self.command(**options)
    return module.target(
      target_name,
      inputs=sources,
      outputs=objects,
      command=command,
      description='Building Object %%in',
      meta_type='objects',
      meta_options=options,
    )

  def executable(self, filename, inputs, module=None, target_name=None, **options):
    ''' Declares a target to build object files from the *sources*. The
    target has the meta type `"executable"`. The calling modules
    `build_dir` variable is used if *filename* is a relative path. '''

    if not filename:
      raise ValueError('filename must not be empty')
    if not inputs:
      raise ValueError('inputs must not be empty')

    module = get_calling_module(module)
    build_dir = module.get('build_dir', None)
    filename = P.bin(normpath(filename, build_dir))

    options['output_type'] = 'executable'
    options = self.merge_options(**options)
    objects = self.process_inputs(module, inputs, options)

    command = self.command(**options)
    return module.target(
      target_name,
      inputs=[objects],
      outputs=filename,
      command=command,
      description='Building Executable %%in',
      meta_type='executable',
      meta_options=options,
    )

  def shared_library(self, filename, inputs, module=None, target_name=None, **options):
    ''' Declares a target to build object files from the *sources*. The
    target has the meta type `"shared_library"`. The calling modules
    `build_dir` variable is used if *filename* is a relative path.  '''

    if not filename:
      raise ValueError('filename must not be empty')
    if not inputs:
      raise ValueError('inputs must not be empty')

    module = get_calling_module(module)
    build_dir = module.get('build_dir', None)
    filename = P.bin(normpath(filename, build_dir))

    options['output_type'] = 'shared_library'
    options = self.merge_options(**options)
    objects = self.process_inputs(module, inputs, options)

    command = self.command(**options)
    return module.target(
      target_name,
      inputs=[objects],
      outputs=filename,
      command=command,
      description='Building Shared Library %%in',
      meta_type='shared_library',
      meta_options=options,
    )

  def static_library(self, filename, inputs, module=None, target_name=None, **options):
    ''' Declares a target to build object files from the *sources*. The
    target has the meta type `"static_library"`. '''

    if not filename:
      raise ValueError('filename must not be empty')
    if not inputs:
      raise ValueError('inputs must not be empty')

    module = get_calling_module(module)
    filename = P.lib(filename)

    options['output_type'] = 'static_library'
    options = self.merge_options(**options)
    objects = self.process_inputs(module, inputs, options)

    command = self.command(**options)
    return module.target(
      target_name,
      inputs=[objects],
      outputs=filename,
      command=command,
      description='Building Static Library %%in',
      meta_type='static_library',
      meta_options=options,
    )

  def obj_copy(self, filename, input, module=None, target_name=None, **options):
    ''' Declares a target to transate the input to the output'''

    if not filename:
      raise ValueError('filename must not be empty')
    if not input:
      raise ValueError('inputs must not be empty')

    module = get_calling_module(module)

    options = self.merge_options(**options)

    if not isinstance(input, Target):
      raise ValueError('input needs to be a Target', type(input))
    if len(input.outputs) != 1:
      raise ValueError('input target should have one output, it has ', len(input.outputs))

    input =  input.outputs[0]

    command = [options['prog'], options['additional_flags'], input, filename]
    return module.target(
      target_name,
      inputs=[input],
      outputs=filename,
      command=command,
      description='Do an objcopy %%in',
      meta_type='obj_copy',
      meta_options=options,
    )

  def run_target(self, runname, input, module=None, target_name=None, **options):
    ''' Declares a target to run, there is not output'''

    if not input:
      raise ValueError('inputs must not be empty')

    module = get_calling_module(module)

    options = self.merge_options(**options)

    if not isinstance(input, Target):
      raise ValueError('input needs to be a Target', type(input))
    if len(input.outputs) != 1:
      raise ValueError('input target should have one output, it has ', len(input.outputs))

    input =  input.outputs[0]

    command = [options['prog'], options['additional_flags'], input]
    return module.target(
      target_name,
      inputs=[input],
      outputs=runname,
      command=command,
      pool='console',
      description='Do an objcopy %%in',
      meta_type='obj_copy',
      meta_options=options,
    )
