# craftr_module(compiler.clang)
#
# Copyright (C) 2015 Niklas Rosenstein
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

import re
import craftr

_base = load_module('compiler.base')


class CCompiler(_base.BaseCompiler):

  name = 'Clang'
  program = 'clang'

  def init_default_options(self):
    self.options.setdefault('lang', 'c')
    super().init_default_options()

  def detect(self, silent=False):
    if self.version:
      return True  # already detected

    try:
      p = Process([self.program, '--version'])
    except (Process.ExitCodeError, OSError) as exc:
      if silent:
        return False
      message = '{} could not be detected on your system. ({})'
      error(message.format(self.name, exc))

    # Clang could be a GCC synonym and the other way round.
    # Check for the GCC version first.
    mv = re.search('gcc version ([\d\.]+)', p.stderr)
    mt = re.search('Target: (\w+)', p.stderr)
    if mv and mt:
      self.name = 'GCC'
      self.version = mv.group(1)
      self.arch = mt.group(1)
      return True

    # Check Clang version.
    mv = re.search('LLVM version ([\d\.]+)', p.stdout)
    mt = re.search('Target: (\w+)', p.stdout)
    if mv and mt:
      self.name = 'Clang'
      self.version = mv.group(1)
      self.arch = mt.group(1)
      return True

    if silent:
      return False
    message = '{} version and architecture could not be detected.'
    error(message.format(self.name))

  def get_file_type(self, fn):
    if P.name == 'Darwin':
      if fn.endswith('.o'):
        return 'object'
      elif fn.endswith('.a'):
        return 'static_library'
      elif fn.endswith('.dylib') or fn.endswith('dylib64'):
        return 'shared_library'
      else:
        return 'executable'
    elif P.name == 'Cygwin':
      if fn.endswith('.o'):
        return 'object'
      elif fn.endswith('.a'):
        return 'static_library'
      elif fn.endswith('.dll'):
        return 'shared_library'
      elif fn.endswith('.exe'):
        return 'executable'
    else:
      if fn.endswith('.o'):
        return 'object'
      elif fn.endswith('.a'):
        return 'static_library'
      elif fn.endswith('.so') or fn.endswith('.so64'):
        return 'shared_library'
      else:
        return 'executable'

    return None

  def flags(self, debug=None, output_type=None, exceptions=None, includes=(),
      defines=(), libs=(), link_with=(), external_libs=(), ldpaths=(),
      additional_flags=(), warning_level=None, std=None, arch=None, lang=None,
      prog=None, **options):
    ''' Generate flags based on the specfied options. '''

    if output_type == 'static_library':
      return ['ar', 'rcs', '%%out', '%%in']

    result = []

    if prog is not None:
      result += [prog]
    else:
      if lang is not None:
        if lang == 'c':
          result += ['clang']
        elif lang == 'c++':
          result += ['clang++']
        else:
          self.invalid_option('lang', lang)

    if arch is not None:
      # XXX: Validate arch value.
      result += ['-arch', arch]

    if exceptions is not None and not exceptions:
      result += ['-fno-exceptions']

    if warning_level is not None:
      if warning_level == 'all':
        result += ['-Wall']
      elif warning_level in (0, 'none'):
        result += ['-w']
      elif 1 <= warning_level <= 4:
        result += ['-W{}'.format(warning_level)]
      else:
        self.invalid_option('warning_level', warning_level)

    if std is not None:
      # XXX: Validate std value.
      result += ['-std={}'.format(std)]

    result.extend(libs)
    result.extend(external_libs)
    result.extend('-I{}'.format(x) for x in includes)
    result.extend('-D{}'.format(x) for x in defines)
    result.extend('-L{}'.format(x) for x in ldpaths)
    result.extend('-l{}'.format(x) for x in link_with)
    result.extend(additional_flags)

    if output_type is not None:
      if output_type == 'object':
        result += ['%%in', '-c', '-o', '%%out']
      elif output_type == 'executable':
        result += ['%%in', '-o', '%%out']
      elif output_type == 'shared_library':
        result += ['-dynamiclib', '%%in', '-o', '%%out']
      else:
        self.invalid_option('output_type', output_type)

    return result

  command = flags


class CxxCompiler(CCompiler):

  def init_default_options(self):
    self.options.setdefault('lang', 'c++')
    super().init_default_options()
